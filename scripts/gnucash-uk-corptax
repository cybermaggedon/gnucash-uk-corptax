#!/usr/bin/env python3

from gnucash_uk_corptax.govtalk import *
from gnucash_uk_corptax.corptax import *

import xml.etree.ElementTree as ET
import lxml.etree
import asyncio
import aiohttp
import time
import xml.dom.minidom
import sys
import argparse
import json
import datetime
import textwrap
import yaml

# Command-line argument parser
parser = argparse.ArgumentParser(
    description="Submittion to HMRC Corporation Tax API"
)
parser.add_argument('--config', '-c',
		    default='config.json',
                    help='Configuration file (default: config.json)')
parser.add_argument('--accounts', '-a', required=False,
                    help='Company accounts iXBRL file')
parser.add_argument('--computations', '--comps', '-t', required=True,
                    help='Corporation tax computations iXBRL file')
parser.add_argument('--form-values', '--ct600', '-f', required=False,
                    help='CT600 form values YAML file')
parser.add_argument('--attachment', '-m', required=False, action='append',
                    help='Corporation tax computations iXBRL file')
parser.add_argument('--output-ct', '-p',
                    action="store_true", default=False,
                    help='Just output submission message, without submit step')
parser.add_argument('--output-values',
                    action="store_true", default=False,
                    help='Just output some data values (debug)')
parser.add_argument('--output-form-values',
                    action="store_true", default=False,
                    help='Output CT600 form values from corptax')
parser.add_argument('--submit',
                    action="store_true", default=False,
                    help='Submit the CT message')
parser.add_argument('--data-request',
                    action="store_true", default=False,
                    help='Perform a data request for outstanding items')

# Parse arguments
args = parser.parse_args(sys.argv[1:])

# Load config
params = json.loads(open(args.config).read())

async def call(req, ep):

    async with aiohttp.ClientSession() as session:

        data = req.toxml()

        async with session.post(ep, data=data) as resp:
            if resp.status != 200:
                print(await resp.text())
                raise RuntimeError(
                    "Transaction failed: status=%d" % resp.status
                )
            data = await resp.text()

            msg = GovTalkMessage.decode(data)

            if isinstance(msg, GovTalkSubmissionError):
                print(data)
                raise RuntimeError(msg.get("error-text"))

            return msg

if args.data_request:

    async def doit():
        req_params = {
            "username": params["username"],
            "password": params["password"],
            "class": "HMRC-CT-CT600",
            "gateway-test": params["gateway-test"],
            "vendor-id": params["vendor-id"],
            "software": params["software"],
            "software-version": params["software-version"],
            "ir-envelope": lxml.etree.Element("asd")
        }

        if "class" in params:
            req_params["class"] = params["class"]

        if "timestamp" in params:
            req_params["timestamp"] = datetime.datetime.fromisoformat(
                params["timestamp"]
            )

        req = GovTalkSubmissionRequest(req_params)
        req.params["function"] = "list"
        req.params["qualifier"] = "request"

        print(req.toxml())
        resp = await call(req, params["url"])
        print(resp)

    loop = asyncio.get_event_loop()
    loop.run_until_complete(doit())

    sys.exit(0)

if args.accounts == None or args.computations == None:
    sys.stderr.write("Need to specify --accounts and --computations\n")
    sys.exit(1)

try:
    accts = open(args.accounts, "rb").read()
except Exception as e:
    sys.stderr.write("Could not read accounts file: %s\n" % str(e))
    sys.exit(1)

try:
    comps = open(args.computations, "rb").read()
except Exception as e:
    sys.stderr.write("Could not read computations file: %s\n" % str(e))
    sys.exit(1)

# Sanity check on inputs, correct schemas in use?

def get_schema(file):
    doc = ET.parse(file)

    schema=set()
    for elt in doc.findall(".//ix:references/link:schemaRef", {
            "link": "http://www.xbrl.org/2003/linkbase",
            "xlink": "http://www.w3.org/1999/xlink",
            "ix": "http://www.xbrl.org/2013/inlineXBRL"
    }):
        schema.add(elt.get("{%s}href" % "http://www.w3.org/1999/xlink"))

    return schema

schema = get_schema(args.accounts)
found_frc=False
found_dpl=False
found_ct=False

for s in schema:
    if s.startswith("https://xbrl.frc.org.uk/FRS-"):
        found_frc = True
    if s.startswith("http://www.hmrc.gov.uk/schemas/ct/dpl/"):
        found_dpl = True

schema = get_schema(args.computations)

for s in schema:
    if s.startswith("http://www.hmrc.gov.uk/schemas/ct/comp/"):
        found_ct = True
    if s.startswith("http://www.hmrc.gov.uk/schemas/ct/dpl/"):
        found_dpl = True

if not found_dpl:
    sys.stderr.write("No DPL schema present in either file!\n")
    sys.stderr.write(
        "One of the files should contain detailed profit-and-loss statement.\n")
    sys.exit(1)

if not found_frc:
    sys.stderr.write("No FRS schema present in company accounts!\n")
    sys.stderr.write("Is it a company accounts file?\n")
    sys.exit(1)

if not found_ct:
    sys.stderr.write("No CT schema present in computations file!\n")
    sys.stderr.write("Is it a corporation tax computations file?\n")
    sys.exit(1)

if args.attachment is not None:
    atts = {
        filename: open(filename, "rb").read()
        for filename in args.attachment
    }
else:
    atts = {}

if args.output_values:

    vals = to_values(comps)

    for c in vals:

        if c.value is None: continue
        
        print(
            "%-4d %-45s: %s" % (c.box, c.description[:44], str(c.value)[:20])
        )

    sys.exit(0)

if args.output_form_values:

    vals = to_values(comps)

    print("ct600:")

    for c in vals:


        print()
        help = "\n  # ".join(textwrap.wrap(c.description, width=75))
        print("  # " + help)

        if c.value is None:
            print("  " + str(c.box) + ": ")
        else:
            print("  " + str(c.box) + ": " + str(c.value))

    print()

    sys.exit(0)

try:
    form_values = open(args.form_values, "r").read()
    form_values = yaml.safe_load(form_values)
except Exception as e:
    sys.stderr.write("Could not read form values file: %s\n" % str(e))
    sys.exit(1)

ret = CorptaxReturn(comps, accts, form_values, params, atts)

rtn = ret.get_return()

utr = rtn.find(".//{%s}Reference" % ct_ns).text

req_params = {
    "username": params["username"],
    "password": params["password"],
    "class": "HMRC-CT-CT600",
    "gateway-test": params["gateway-test"],
    "tax-reference": utr,
    "vendor-id": params["vendor-id"],
    "software": params["software"],
    "software-version": params["software-version"],
    "ir-envelope": rtn.getroot()
}

if "class" in params:
    req_params["class"] = params["class"]

if "timestamp" in params:
    req_params["timestamp"] = datetime.datetime.fromisoformat(
        params["timestamp"]
    )

req = GovTalkSubmissionRequest(req_params)

print(req.toprettyxml())


sys.exit(0)

utr = ret.find(".//{%s}Reference" % ct_ns).text

req_params = {
    "username": params["username"],
    "password": params["password"],
    "class": "HMRC-CT-CT600",
    "gateway-test": params["gateway-test"],
    "tax-reference": utr,
    "vendor-id": params["vendor-id"],
    "software": params["software"],
    "software-version": params["software-version"],
    "ir-envelope": ret.getroot()
}

if "class" in params:
    req_params["class"] = params["class"]

if "timestamp" in params:
    req_params["timestamp"] = datetime.datetime.fromisoformat(
        params["timestamp"]
    )

req = GovTalkSubmissionRequest(req_params)

req.add_irmark()

if args.output_ct:
    print(req.toprettyxml())
    sys.exit(0)

if not args.submit:
    sys.stderr.write("--submit was not specified.  No action will be taken.\n")
    sys.exit(0)

print("IRmark is", req.get_irmark())

async def submit(req):

    resp = await call(req, params["url"])

    correlation_id = resp.get("correlation-id")
    endpoint = resp.get("response-endpoint")
    try:
        poll = float(resp.get("poll-interval"))
    except:
        poll = None

    print("Correlation ID is", correlation_id)

    timeout = time.time() + 120
    
    while not isinstance(resp, GovTalkSubmissionResponse):

        if time.time() > timeout:
            raise RuntimeError("Timeout waiting for valid response.")

        if poll == None:
            raise RuntimeError(
                "Should be polling, but have no poll information?"
            )

        await asyncio.sleep(poll)

        req = GovTalkSubmissionPoll({
	    "username": params["username"],
	    "password": params["password"],
	    "class": "HMRC-CT-CT600",
	    "gateway-test": params["gateway-test"],
            "correlation-id": correlation_id
        })

        print("Poll...")
        resp = await call(req, endpoint)

        correlation_id = resp.get("correlation-id")
        endpoint = resp.get("response-endpoint")
        try:
            poll = float(resp.get("poll-interval"))
        except:
            poll = None

    sr = resp.get("success-response")
    for elt in sr.findall(".//" + sr_Message):
        print("- Message " + "-" * 68)
        print(elt.text)
    print("-" * 76)

    print("Submission was successful.")

    if correlation_id == None or correlation_id == "":
        print("Completed.")
        return

    req = GovTalkDeleteRequest({
	"username": params["username"],
	"password": params["password"],
	"class": "HMRC-CT-CT600",
	"gateway-test": params["gateway-test"],
        "correlation-id": correlation_id
    })

    print("Delete request...")
    resp = await call(req, endpoint)

    print("Completed.")

try:
    loop = asyncio.get_event_loop()
    loop.run_until_complete(submit(req))
except Exception as e:
    print("Exception:", str(e))
    raise e

